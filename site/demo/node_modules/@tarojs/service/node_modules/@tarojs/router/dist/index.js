'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var runtime = require('@tarojs/runtime');

function _extends() {
  _extends = Object.assign || function (target) {
    var arguments$1 = arguments;

    for (var i = 1; i < arguments.length; i++) {
      var source = arguments$1[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var r,B=r||(r={});B.Pop="POP";B.Push="PUSH";B.Replace="REPLACE";var C="production"!==process.env.NODE_ENV?function(b){return Object.freeze(b)}:function(b){return b};function D(b,h){if(!b){"undefined"!==typeof console&&console.warn(h);try{throw Error(h);}catch(k){}}}function E(b){b.preventDefault();b.returnValue="";}
function F(){var b=[];return {get length(){return b.length},push:function(h){b.push(h);return function(){b=b.filter(function(k){return k!==h});}},call:function(h){b.forEach(function(k){return k&&k(h)});}}}function H(){return Math.random().toString(36).substr(2,8)}function I(b){var h=b.pathname,k=b.search;b=b.hash;return (void 0===h?"/":h)+(void 0===k?"":k)+(void 0===b?"":b)}
function J(b){var h={};if(b){var k=b.indexOf("#");0<=k&&(h.hash=b.substr(k),b=b.substr(0,k));k=b.indexOf("?");0<=k&&(h.search=b.substr(k),b=b.substr(0,k));b&&(h.pathname=b);}return h}
function createBrowserHistory(b){function h(){var c=p.location,a=m.state||{};return [a.idx,C({pathname:c.pathname,search:c.search,hash:c.hash,state:a.usr||null,key:a.key||"default"})]}function k(c){return "string"===typeof c?c:I(c)}function x(c,a){void 0===a&&(a=null);return C(_extends({},q,"string"===typeof c?J(c):c,{state:a,key:H()}))}function z(c){t=c;c=h();v=c[0];q=c[1];d.call({action:t,location:q});}function A(c,a){function e(){A(c,a);}var l=r.Push,g=x(c,a);if(!f.length||(f.call({action:l,
location:g,retry:e}),!1)){var n=[{usr:g.state,key:g.key,idx:v+1},k(g)];g=n[0];n=n[1];try{m.pushState(g,"",n);}catch(G){p.location.assign(n);}z(l);}}function y(c,a){function e(){y(c,a);}var l=r.Replace,g=x(c,a);f.length&&(f.call({action:l,location:g,retry:e}),1)||(g=[{usr:g.state,key:g.key,idx:v},k(g)],m.replaceState(g[0],"",g[1]),z(l));}function w(c){m.go(c);}void 0===b&&(b={});b=b.window;var p=void 0===b?document.defaultView:b,m=p.history,u=null;p.addEventListener("popstate",function(){if(u){ f.call(u),
u=null; }else {var c=r.Pop,a=h(),e=a[0];a=a[1];if(f.length){ if(null!=e){var l=v-e;l&&(u={action:c,location:a,retry:function(){w(-1*l);}},w(l));}else { "production"!==process.env.NODE_ENV?D(!1,"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation."):void 0; } }else { z(c); }}});var t=
r.Pop;b=h();var v=b[0],q=b[1],d=F(),f=F();null==v&&(v=0,m.replaceState(_extends({},m.state,{idx:v}),""));return {get action(){return t},get location(){return q},createHref:k,push:A,replace:y,go:w,back:function(){w(-1);},forward:function(){w(1);},listen:function(c){return d.push(c)},block:function(c){var a=f.push(c);1===f.length&&p.addEventListener("beforeunload",E);return function(){a();f.length||p.removeEventListener("beforeunload",E);}}}}function createHashHistory(b){function h(){var a=J(m.location.hash.substr(1)),e=a.pathname,l=a.search;a=a.hash;var g=u.state||{};return [g.idx,C({pathname:void 0===e?"/":e,search:void 0===l?"":l,hash:void 0===a?"":a,state:g.usr||null,key:g.key||"default"})]}function k(){if(t){ c.call(t),t=null; }else {var a=r.Pop,e=h(),l=e[0];e=e[1];if(c.length){ if(null!=l){var g=q-l;g&&(t={action:a,location:e,retry:function(){p(-1*g);}},p(g));}else { "production"!==process.env.NODE_ENV?D(!1,"You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation."):
void 0; } }else { A(a); }}}function x(a){var e=document.querySelector("base"),l="";e&&e.getAttribute("href")&&(e=m.location.href,l=e.indexOf("#"),l=-1===l?e:e.slice(0,l));return l+"#"+("string"===typeof a?a:I(a))}function z(a,e){void 0===e&&(e=null);return C(_extends({},d,"string"===typeof a?J(a):a,{state:e,key:H()}))}function A(a){v=a;a=h();q=a[0];d=a[1];f.call({action:v,location:d});}function y(a,e){function l(){y(a,e);}var g=r.Push,n=z(a,e);"production"!==process.env.NODE_ENV?D("/"===n.pathname.charAt(0),
"Relative pathnames are not supported in hash history.push("+JSON.stringify(a)+")"):void 0;if(!c.length||(c.call({action:g,location:n,retry:l}),!1)){var G=[{usr:n.state,key:n.key,idx:q+1},x(n)];n=G[0];G=G[1];try{u.pushState(n,"",G);}catch(K){m.location.assign(G);}A(g);}}function w(a,e){function l(){w(a,e);}var g=r.Replace,n=z(a,e);"production"!==process.env.NODE_ENV?D("/"===n.pathname.charAt(0),"Relative pathnames are not supported in hash history.replace("+JSON.stringify(a)+")"):void 0;c.length&&(c.call({action:g,
location:n,retry:l}),1)||(n=[{usr:n.state,key:n.key,idx:q},x(n)],u.replaceState(n[0],"",n[1]),A(g));}function p(a){u.go(a);}void 0===b&&(b={});b=b.window;var m=void 0===b?document.defaultView:b,u=m.history,t=null;m.addEventListener("popstate",k);m.addEventListener("hashchange",function(){var a=h()[1];I(a)!==I(d)&&k();});var v=r.Pop;b=h();var q=b[0],d=b[1],f=F(),c=F();null==q&&(q=0,u.replaceState(_extends({},u.state,{idx:q}),""));return {get action(){return v},get location(){return d},createHref:x,push:y,
replace:w,go:p,back:function(){p(-1);},forward:function(){p(1);},listen:function(a){return f.push(a)},block:function(a){var e=c.push(a);1===c.length&&m.addEventListener("beforeunload",E);return function(){e();c.length||m.removeEventListener("beforeunload",E);}}}}

var basename = '/';
function setHistoryMode(mode, base) {
    if ( base === void 0 ) base = '/';

    var options = {
        window: window
    };
    basename = base;
    if (mode === 'browser') {
        exports.history = createBrowserHistory(options);
    }
    else {
        // default is hash
        exports.history = createHashHistory(options);
    }
}
function parsePath(url) {
    if ( url === void 0 ) url = '';

    return basename.replace(/\/$/, '') + '/' + url.replace(/^\//, '');
}

var stacks = [];

var routesAlias = {};
function setRoutesAlias(alias) {
    routesAlias = alias;
}
function addLeadingSlash(path) {
    if (path == null) {
        return '';
    }
    return path.charAt(0) === '/' ? path : '/' + path;
}
// 解决navigateBack调用delta>1时,路由栈异常问题
// 比如:A->B->C,navigateBack({delta: 2}),此时路由栈中还存在B页面
// 原因:主要是由于一次性退出多层级页面时,此action只会执行一次,此处进行手动处理
var historyBackDelta = 1;
function setHistoryBackDelta(delta) {
    historyBackDelta = delta;
}
// eslint-disable-next-line @typescript-eslint/ban-types
var throttle = function (fn, threshold) {
    var lastTime = 0;
    return function () {
        var now = Date.now();
        if (now - lastTime > threshold) {
            fn.apply(this, arguments);
            lastTime = now;
        }
    };
};

function processNavigateUrl(option) {
    var url = option.url;
    var matches = option.url.match(/[?&?].*/);
    var parameters = '';
    if (matches && matches.length) {
        parameters = matches[0];
        url = url.replace(parameters, '');
    }
    Object.keys(routesAlias).forEach(function (key) {
        if (addLeadingSlash(key) === addLeadingSlash(url)) {
            option.url = routesAlias[key] + parameters;
        }
    });
}
function navigate(option, method) {
    var success = option.success;
    var complete = option.complete;
    var fail = option.fail;
    var failReason;
    if (option.url) {
        processNavigateUrl(option);
    }
    try {
        if (method === 'navigateTo') {
            exports.history.push(parsePath(option.url), { timestamp: Date.now() });
        }
        else if (method === 'redirectTo') {
            exports.history.replace(parsePath(option.url), { timestamp: Date.now() });
        }
        else if (method === 'navigateBack') {
            setHistoryBackDelta(option.delta);
            exports.history.go(-option.delta);
        }
    }
    catch (error) {
        failReason = error;
    }
    return new Promise(function (resolve, reject) {
        if (failReason) {
            fail && fail(failReason);
            complete && complete();
            reject(failReason);
            return;
        }
        var unlisten = exports.history.listen(function () {
            success && success();
            complete && complete();
            resolve();
            unlisten();
        });
    });
}
function navigateTo(option) {
    return navigate(option, 'navigateTo');
}
function redirectTo(option) {
    return navigate(option, 'redirectTo');
}
function navigateBack(options) {
    if ( options === void 0 ) options = { delta: 1 };

    if (!options.delta || options.delta < 1) {
        options.delta = 1;
    }
    return navigate(options, 'navigateBack');
}
function switchTab(option) {
    return navigateTo(option);
}
function reLaunch(option) {
    return redirectTo(option);
}
function getCurrentPages() {
    return stacks;
}

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var match_1 = match;
var regexpToFunction_1 = regexpToFunction;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * Default configs.
 */
var DEFAULT_DELIMITER = '/';

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // ":test(\\d+)?" => ["test", "\d+", undefined, "?"]
  // "(\\d+)"  => [undefined, undefined, "\d+", undefined]
  '(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = (options && options.delimiter) || DEFAULT_DELIMITER;
  var whitelist = (options && options.whitelist) || undefined;
  var pathEscaped = false;
  var res;

  while ((res = PATH_REGEXP.exec(str)) !== null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      pathEscaped = true;
      continue
    }

    var prev = '';
    var name = res[2];
    var capture = res[3];
    var group = res[4];
    var modifier = res[5];

    if (!pathEscaped && path.length) {
      var k = path.length - 1;
      var c = path[k];
      var matches = whitelist ? whitelist.indexOf(c) > -1 : true;

      if (matches) {
        prev = c;
        path = path.slice(0, k);
      }
    }

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
      pathEscaped = false;
    }

    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var pattern = capture || group;
    var delimiter = prev || defaultDelimiter;

    tokens.push({
      name: name || key++,
      prefix: prev,
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      pattern: pattern
        ? escapeGroup(pattern)
        : '[^' + escapeString(delimiter === defaultDelimiter ? delimiter : (delimiter + defaultDelimiter)) + ']+?'
    });
  }

  // Push any remaining characters.
  if (path || index < str.length) {
    tokens.push(path + str.substr(index));
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options), options)
}

/**
 * Create path match function from `path-to-regexp` spec.
 */
function match (str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys)
}

/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction (re, keys) {
  return function (pathname, options) {
    var m = re.exec(pathname);
    if (!m) { return false }

    var path = m[0];
    var index = m.index;
    var params = {};
    var decode = (options && options.decode) || decodeURIComponent;

    for (var i = 1; i < m.length; i++) {
      if (m[i] === undefined) { continue }

      var key = keys[i - 1];

      if (key.repeat) {
        params[key.name] = m[i].split(key.delimiter).map(function (value) {
          return decode(value, key)
        });
      } else {
        params[key.name] = decode(m[i], key);
      }
    }

    return { path: path, index: index, params: params }
  }
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));
    }
  }

  return function (data, options) {
    var path = '';
    var encode = (options && options.encode) || encodeURIComponent;
    var validate = options ? options.validate !== false : true;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;
        continue
      }

      var value = data ? data[token.name] : undefined;
      var segment;

      if (Array.isArray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but got array')
        }

        if (value.length === 0) {
          if (token.optional) { continue }

          throw new TypeError('Expected "' + token.name + '" to not be empty')
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j], token);

          if (validate && !matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '"')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        segment = encode(String(value), token);

        if (validate && !matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"')
        }

        path += token.prefix + segment;
        continue
      }

      if (token.optional) { continue }

      throw new TypeError('Expected "' + token.name + '" to be ' + (token.repeat ? 'an array' : 'a string'))
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$/()])/g, '\\$1')
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {Array=}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  if (!keys) { return path }

  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        pattern: null
      });
    }
  }

  return path
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  return new RegExp('(?:' + parts.join('|') + ')', flags(options))
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}  tokens
 * @param  {Array=}  keys
 * @param  {Object=} options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  options = options || {};

  var strict = options.strict;
  var start = options.start !== false;
  var end = options.end !== false;
  var delimiter = options.delimiter || DEFAULT_DELIMITER;
  var endsWith = [].concat(options.endsWith || []).map(escapeString).concat('$').join('|');
  var route = start ? '^' : '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var capture = token.repeat
        ? '(?:' + token.pattern + ')(?:' + escapeString(token.delimiter) + '(?:' + token.pattern + '))*'
        : token.pattern;

      if (keys) { keys.push(token); }

      if (token.optional) {
        if (!token.prefix) {
          route += '(' + capture + ')?';
        } else {
          route += '(?:' + escapeString(token.prefix) + '(' + capture + '))?';
        }
      } else {
        route += escapeString(token.prefix) + '(' + capture + ')';
      }
    }
  }

  if (end) {
    if (!strict) { route += '(?:' + escapeString(delimiter) + ')?'; }

    route += endsWith === '$' ? '$' : '(?=' + endsWith + ')';
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === 'string'
      ? endToken[endToken.length - 1] === delimiter
      : endToken === undefined;

    if (!strict) { route += '(?:' + escapeString(delimiter) + '(?=' + endsWith + '))?'; }
    if (!isEndDelimited) { route += '(?=' + escapeString(delimiter) + '|' + endsWith + ')'; }
  }

  return new RegExp(route, flags(options))
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {Array=}                keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys)
  }

  if (Array.isArray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), keys, options)
  }

  return stringToRegexp(/** @type {string} */ (path), keys, options)
}
pathToRegexp_1.match = match_1;
pathToRegexp_1.regexpToFunction = regexpToFunction_1;
pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/*! Universal Router | MIT License | https://www.kriasoft.com/universal-router/ */

var hasOwnProperty = Object.prototype.hasOwnProperty;
var cache = new Map();

function decodeParam(val) {
  try {
    return decodeURIComponent(val);
  } catch (err) {
    return val;
  }
}

function matchPath(route, pathname, parentKeys, parentParams) {
  var end = !route.children;
  var cacheKey = (route.path || '') + "|" + end;
  var regexp = cache.get(cacheKey);

  if (!regexp) {
    var keys = [];
    regexp = {
      keys: keys,
      pattern: pathToRegexp_1(route.path || '', keys, {
        end: end
      })
    };
    cache.set(cacheKey, regexp);
  }

  var m = regexp.pattern.exec(pathname);

  if (!m) {
    return null;
  }

  var path = m[0];
  var params = Object.assign({}, parentParams);

  for (var i = 1; i < m.length; i++) {
    var key = regexp.keys[i - 1];
    var prop = key.name;
    var value = m[i];

    if (value !== undefined || !hasOwnProperty.call(params, prop)) {
      if (key.repeat) {
        params[prop] = value ? value.split(key.delimiter).map(decodeParam) : [];
      } else {
        params[prop] = value ? decodeParam(value) : value;
      }
    }
  }

  return {
    path: !end && path.charAt(path.length - 1) === '/' ? path.substr(1) : path,
    keys: parentKeys.concat(regexp.keys),
    params: params
  };
}

function matchRoute(route, baseUrl, pathname, parentKeys, parentParams) {
  var match;
  var childMatches;
  var childIndex = 0;
  return {
    next: function next(routeToSkip) {
      if (route === routeToSkip) {
        return {
          done: true
        };
      }

      if (!match) {
        match = matchPath(route, pathname, parentKeys, parentParams);

        if (match) {
          return {
            done: false,
            value: {
              route: route,
              baseUrl: baseUrl,
              path: match.path,
              keys: match.keys,
              params: match.params
            }
          };
        }
      }

      if (match && route.children) {
        while (childIndex < route.children.length) {
          if (!childMatches) {
            var childRoute = route.children[childIndex];
            childRoute.parent = route;
            childMatches = matchRoute(childRoute, baseUrl + match.path, pathname.substr(match.path.length), match.keys, match.params);
          }

          var childMatch = childMatches.next(routeToSkip);

          if (!childMatch.done) {
            return {
              done: false,
              value: childMatch.value
            };
          }

          childMatches = null;
          childIndex++;
        }
      }

      return {
        done: true
      };
    }
  };
}

function resolveRoute(context, params) {
  if (typeof context.route.action === 'function') {
    return context.route.action(context, params);
  }

  return undefined;
}

function isChildRoute(parentRoute, childRoute) {
  var route = childRoute;

  while (route) {
    route = route.parent;

    if (route === parentRoute) {
      return true;
    }
  }

  return false;
}

var UniversalRouter = function () {
  function UniversalRouter(routes, options) {
    if (options === void 0) {
      options = {};
    }

    if (!routes || typeof routes !== 'object') {
      throw new TypeError('Invalid routes');
    }

    this.baseUrl = options.baseUrl || '';
    this.errorHandler = options.errorHandler;
    this.resolveRoute = options.resolveRoute || resolveRoute;
    this.context = Object.assign({
      router: this
    }, options.context);
    this.root = Array.isArray(routes) ? {
      path: '',
      children: routes,
      parent: null
    } : routes;
    this.root.parent = null;
  }

  var _proto = UniversalRouter.prototype;

  _proto.resolve = function resolve(pathnameOrContext) {
    var _this = this;

    var context = Object.assign({}, this.context, {}, typeof pathnameOrContext === 'string' ? {
      pathname: pathnameOrContext
    } : pathnameOrContext);
    var match = matchRoute(this.root, this.baseUrl, context.pathname.substr(this.baseUrl.length), [], null);
    var resolve = this.resolveRoute;
    var matches = null;
    var nextMatches = null;
    var currentContext = context;

    function next(resume, parent, prevResult) {
      if (parent === void 0) {
        parent = matches.value.route;
      }

      var routeToSkip = prevResult === null && !matches.done && matches.value.route;
      matches = nextMatches || match.next(routeToSkip);
      nextMatches = null;

      if (!resume) {
        if (matches.done || !isChildRoute(parent, matches.value.route)) {
          nextMatches = matches;
          return Promise.resolve(null);
        }
      }

      if (matches.done) {
        var error = new Error('Route not found');
        error.status = 404;
        return Promise.reject(error);
      }

      currentContext = Object.assign({}, context, {}, matches.value);
      return Promise.resolve(resolve(currentContext, matches.value.params)).then(function (result) {
        if (result !== null && result !== undefined) {
          return result;
        }

        return next(resume, parent, result);
      });
    }

    context.next = next;
    return Promise.resolve().then(function () {
      return next(true, _this.root);
    })["catch"](function (error) {
      if (_this.errorHandler) {
        return _this.errorHandler(error, currentContext);
      }

      throw error;
    });
  };

  return UniversalRouter;
}();

UniversalRouter.pathToRegexp = pathToRegexp_1;

function initTabbar(config) {
    if (config.tabBar == null) {
        return;
    }
    // TODO: 找到 tabbar 的类型
    var tabbar = document.createElement('taro-tabbar');
    var homePage = config.pages ? config.pages[0] : '';
    tabbar.conf = config.tabBar;
    tabbar.conf.homePage = exports.history.location.pathname === '/' ? homePage : exports.history.location.pathname;
    var routerConfig = config.router;
    tabbar.conf.mode = routerConfig && routerConfig.mode ? routerConfig.mode : 'hash';
    tabbar.conf.custom = !!routerConfig.customRoutes;
    if (routerConfig.customRoutes) {
        tabbar.conf.custom = true;
        tabbar.conf.customRoutes = routerConfig.customRoutes;
    }
    else {
        tabbar.conf.custom = false;
        tabbar.conf.customRoutes = {};
    }
    var container = document.getElementById('container');
    // eslint-disable-next-line no-unused-expressions
    container === null || container === void 0 ? void 0 : container.appendChild(tabbar);
}

var routerConfig = Object.create(null);
function init(config) {
    var _a;
    config.router.mode = config.router.mode || 'hash';
    setHistoryMode(config.router.mode, config.router.basename);
    Object.assign(routerConfig, config);
    (_a = document.getElementById('app')) === null || _a === void 0 ? void 0 : _a.remove();
    var container = document.createElement('div');
    container.classList.add('taro-tabbar__container');
    container.id = 'container';
    var panel = document.createElement('div');
    panel.classList.add('taro-tabbar__panel');
    var app = document.createElement('div');
    app.id = 'app';
    app.classList.add('taro_router');
    panel.appendChild(app);
    container.appendChild(panel);
    document.body.appendChild(container);
    initTabbar(config);
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var strictUriEncode = function (str) { return encodeURIComponent(str).replace(/[!'()*]/g, function (x) { return ("%" + (x.charCodeAt(0).toString(16).toUpperCase())); }); };

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

var decodeUriComponent = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};

var splitOnFirst = function (string, separator) {
	if (!(typeof string === 'string' && typeof separator === 'string')) {
		throw new TypeError('Expected the arguments to be of type `string`');
	}

	if (separator === '') {
		return [string];
	}

	var separatorIndex = string.indexOf(separator);

	if (separatorIndex === -1) {
		return [string];
	}

	return [
		string.slice(0, separatorIndex),
		string.slice(separatorIndex + separator.length)
	];
};

var filterObj = function (obj, predicate) {
	var ret = {};
	var keys = Object.keys(obj);
	var isArr = Array.isArray(predicate);

	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var val = obj[key];

		if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
			ret[key] = val;
		}
	}

	return ret;
};

var queryString = createCommonjsModule(function (module, exports) {





var isNullOrUndefined = function (value) { return value === null || value === undefined; };

function encoderForArrayFormat(options) {
	switch (options.arrayFormat) {
		case 'index':
			return function (key) { return function (result, value) {
				var index = result.length;

				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return result.concat( [[encode(key, options), '[', index, ']'].join('')]);
				}

				return result.concat( [[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')]
				);
			}; };

		case 'bracket':
			return function (key) { return function (result, value) {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return result.concat( [[encode(key, options), '[]'].join('')]);
				}

				return result.concat( [[encode(key, options), '[]=', encode(value, options)].join('')]);
			}; };

		case 'comma':
		case 'separator':
			return function (key) { return function (result, value) {
				if (value === null || value === undefined || value.length === 0) {
					return result;
				}

				if (result.length === 0) {
					return [[encode(key, options), '=', encode(value, options)].join('')];
				}

				return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
			}; };

		default:
			return function (key) { return function (result, value) {
				if (
					value === undefined ||
					(options.skipNull && value === null) ||
					(options.skipEmptyString && value === '')
				) {
					return result;
				}

				if (value === null) {
					return result.concat( [encode(key, options)]);
				}

				return result.concat( [[encode(key, options), '=', encode(value, options)].join('')]);
			}; };
	}
}

function parserForArrayFormat(options) {
	var result;

	switch (options.arrayFormat) {
		case 'index':
			return function (key, value, accumulator) {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return function (key, value, accumulator) {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		case 'comma':
		case 'separator':
			return function (key, value, accumulator) {
				var isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
				var isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
				value = isEncodedArray ? decode(value, options) : value;
				var newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(function (item) { return decode(item, options); }) : value === null ? value : decode(value, options);
				accumulator[key] = newValue;
			};

		default:
			return function (key, value, accumulator) {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function validateArrayFormatSeparator(value) {
	if (typeof value !== 'string' || value.length !== 1) {
		throw new TypeError('arrayFormatSeparator must be single character string');
	}
}

function encode(value, options) {
	if (options.encode) {
		return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function decode(value, options) {
	if (options.decode) {
		return decodeUriComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	}

	if (typeof input === 'object') {
		return keysSorter(Object.keys(input))
			.sort(function (a, b) { return Number(a) - Number(b); })
			.map(function (key) { return input[key]; });
	}

	return input;
}

function removeHash(input) {
	var hashStart = input.indexOf('#');
	if (hashStart !== -1) {
		input = input.slice(0, hashStart);
	}

	return input;
}

function getHash(url) {
	var hash = '';
	var hashStart = url.indexOf('#');
	if (hashStart !== -1) {
		hash = url.slice(hashStart);
	}

	return hash;
}

function extract(input) {
	input = removeHash(input);
	var queryStart = input.indexOf('?');
	if (queryStart === -1) {
		return '';
	}

	return input.slice(queryStart + 1);
}

function parseValue(value, options) {
	if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {
		value = Number(value);
	} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
		value = value.toLowerCase() === 'true';
	}

	return value;
}

function parse(query, options) {
	options = Object.assign({
		decode: true,
		sort: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ',',
		parseNumbers: false,
		parseBooleans: false
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	var formatter = parserForArrayFormat(options);

	// Create an object with no prototype
	var ret = Object.create(null);

	if (typeof query !== 'string') {
		return ret;
	}

	query = query.trim().replace(/^[?#&]/, '');

	if (!query) {
		return ret;
	}

	for (var param of query.split('&')) {
		if (param === '') {
			continue;
		}

		var ref = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');
		var key = ref[0];
		var value = ref[1];

		// Missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
		formatter(decode(key, options), value, ret);
	}

	for (var key$1 of Object.keys(ret)) {
		var value$1 = ret[key$1];
		if (typeof value$1 === 'object' && value$1 !== null) {
			for (var k of Object.keys(value$1)) {
				value$1[k] = parseValue(value$1[k], options);
			}
		} else {
			ret[key$1] = parseValue(value$1, options);
		}
	}

	if (options.sort === false) {
		return ret;
	}

	return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce(function (result, key) {
		var value = ret[key];
		if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
			// Sort object keys, not values
			result[key] = keysSorter(value);
		} else {
			result[key] = value;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = function (object, options) {
	if (!object) {
		return '';
	}

	options = Object.assign({
		encode: true,
		strict: true,
		arrayFormat: 'none',
		arrayFormatSeparator: ','
	}, options);

	validateArrayFormatSeparator(options.arrayFormatSeparator);

	var shouldFilter = function (key) { return (
		(options.skipNull && isNullOrUndefined(object[key])) ||
		(options.skipEmptyString && object[key] === '')
	); };

	var formatter = encoderForArrayFormat(options);

	var objectCopy = {};

	for (var key of Object.keys(object)) {
		if (!shouldFilter(key)) {
			objectCopy[key] = object[key];
		}
	}

	var keys = Object.keys(objectCopy);

	if (options.sort !== false) {
		keys.sort(options.sort);
	}

	return keys.map(function (key) {
		var value = object[key];

		if (value === undefined) {
			return '';
		}

		if (value === null) {
			return encode(key, options);
		}

		if (Array.isArray(value)) {
			return value
				.reduce(formatter(key), [])
				.join('&');
		}

		return encode(key, options) + '=' + encode(value, options);
	}).filter(function (x) { return x.length > 0; }).join('&');
};

exports.parseUrl = function (url, options) {
	options = Object.assign({
		decode: true
	}, options);

	var ref = splitOnFirst(url, '#');
	var url_ = ref[0];
	var hash = ref[1];

	return Object.assign(
		{
			url: url_.split('?')[0] || '',
			query: parse(extract(url), options)
		},
		options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
	);
};

exports.stringifyUrl = function (object, options) {
	options = Object.assign({
		encode: true,
		strict: true
	}, options);

	var url = removeHash(object.url).split('?')[0] || '';
	var queryFromUrl = exports.extract(object.url);
	var parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

	var query = Object.assign(parsedQueryFromUrl, object.query);
	var queryString = exports.stringify(query, options);
	if (queryString) {
		queryString = "?" + queryString;
	}

	var hash = getHash(object.url);
	if (object.fragmentIdentifier) {
		hash = "#" + (encode(object.fragmentIdentifier, options));
	}

	return ("" + url + queryString + hash);
};

exports.pick = function (input, filter, options) {
	options = Object.assign({
		parseFragmentIdentifier: true
	}, options);

	var ref = exports.parseUrl(input, options);
	var url = ref.url;
	var query = ref.query;
	var fragmentIdentifier = ref.fragmentIdentifier;
	return exports.stringifyUrl({
		url: url,
		query: filterObj(query, filter),
		fragmentIdentifier: fragmentIdentifier
	}, options);
};

exports.exclude = function (input, filter, options) {
	var exclusionFilter = Array.isArray(filter) ? function (key) { return !filter.includes(key); } : function (key, value) { return !filter(key, value); };

	return exports.pick(input, exclusionFilter, options);
};
});
var queryString_1 = queryString.extract;
var queryString_2 = queryString.parse;
var queryString_3 = queryString.stringify;
var queryString_4 = queryString.parseUrl;
var queryString_5 = queryString.stringifyUrl;
var queryString_6 = queryString.pick;
var queryString_7 = queryString.exclude;

var qs = function (stamp) {
    if ( stamp === void 0 ) stamp = 0;

    var search = routerConfig.router.mode === 'hash'
        ? location.hash.slice(routerConfig.router.pathname.length + 1)
        : location.search;
    var query = search
        ? queryString.parse(search.substr(1))
        : {};
    if (stamp) {
        query.stamp = stamp.toString();
    }
    return query;
};

var pageScrollFn;
var pageDOM = window;
function bindPageScroll(page, config) {
    pageDOM.removeEventListener('scroll', pageScrollFn);
    pageDOM = getScrollContainer();
    var distance = config.onReachBottomDistance || 50;
    var isReachBottom = false;
    pageScrollFn = function () {
        page.onPageScroll && page.onPageScroll({
            scrollTop: pageDOM instanceof Window ? window.scrollY : pageDOM.scrollTop
        });
        if (isReachBottom && getOffset() > distance) {
            isReachBottom = false;
        }
        if (page.onReachBottom &&
            !isReachBottom &&
            getOffset() < distance) {
            isReachBottom = true;
            page.onReachBottom();
        }
    };
    pageDOM.addEventListener('scroll', pageScrollFn, false);
}
window.addEventListener('DOMSubtreeModified', function (e) {
    var _a;
    // @ts-ignore
    var className = (_a = e.target) === null || _a === void 0 ? void 0 : _a.className;
    if (className && /taro-tabbar__/.test(className)) {
        pageDOM.removeEventListener('scroll', pageScrollFn);
        pageDOM = getScrollContainer();
        pageDOM.addEventListener('scroll', pageScrollFn, false);
    }
}, false);
function getScrollContainer() {
    if (document.querySelector('.taro-tabbar__tabbar') === null) {
        // 没设置tabbar
        return window;
    }
    else {
        // 有设置tabbar
        return document.querySelector('.taro-tabbar__panel') || window;
    }
}
function getOffset() {
    if (pageDOM instanceof Window) {
        return document.documentElement.scrollHeight - window.scrollY - window.innerHeight;
    }
    else {
        return pageDOM.scrollHeight - pageDOM.scrollTop - pageDOM.clientHeight;
    }
}

/* eslint-disable dot-notation */
function hidePage(page) {
    if (page != null) {
        page.onHide();
        var pageEl = document.getElementById(page.path);
        if (pageEl) {
            pageEl.style.display = 'none';
        }
    }
}
function showPage(page, pageConfig, stacksIndex) {
    if ( stacksIndex === void 0 ) stacksIndex = 0;

    if (page != null) {
        page.onShow();
        var pageEl = document.getElementById(page.path);
        if (pageEl) {
            pageEl.style.display = 'block';
        }
        else {
            page.onLoad(qs(stacksIndex));
            pageEl = document.getElementById(page.path);
            pageOnReady(pageEl, page, false);
        }
        bindPageScroll(page, pageConfig || {});
    }
}
function unloadPage(page) {
    if (page != null) {
        stacks.pop();
        page.onUnload();
    }
}
function pageOnReady(pageEl, page, onLoad) {
    if ( onLoad === void 0 ) onLoad = true;

    var _a;
    if (pageEl && !(pageEl === null || pageEl === void 0 ? void 0 : pageEl['__isReady'])) {
        var el = pageEl.firstElementChild;
        // eslint-disable-next-line no-unused-expressions
        (_a = el === null || el === void 0 ? void 0 : el['componentOnReady']) === null || _a === void 0 ? void 0 : _a.call(el).then(function () {
            runtime.requestAnimationFrame(function () {
                page.onReady();
                pageEl['__isReady'] = true;
            });
        });
        onLoad && (pageEl['__page'] = page);
    }
}
function loadPage(page, pageConfig, stacksIndex) {
    if ( stacksIndex === void 0 ) stacksIndex = 0;

    if (page !== null) {
        var pageEl = document.getElementById(page.path);
        if (pageEl) {
            pageEl.style.display = 'block';
        }
        else {
            page.onLoad(qs(stacksIndex), function () {
                pageEl = document.getElementById(page.path);
                pageOnReady(pageEl, page);
            });
        }
        stacks.push(page);
        page.onShow();
        bindPageScroll(page, pageConfig || {});
    }
}
function createRouter(app, config, framework) {
    var _a;
    init(config);
    var routes = [];
    var alias = (_a = config.router.customRoutes) !== null && _a !== void 0 ? _a : {};
    var runtimeHooks = runtime.container.get(runtime.SERVICE_IDENTIFIER.Hooks);
    setRoutesAlias(alias);
    for (var i = 0; i < config.routes.length; i++) {
        var route = config.routes[i];
        var path = addLeadingSlash(route.path);
        routes.push({
            path: alias[path] || path,
            action: route.load
        });
    }
    var basename = config.router.basename;
    var router = new UniversalRouter(routes, { baseUrl: basename || '' });
    app.onLaunch();
    var render = throttle(async function (ref) {
        var location = ref.location;
        var action = ref.action;

        var _a, _b, _c, _d;
        routerConfig.router.pathname = location.pathname;
        var element;
        try {
            element = await router.resolve(config.router.forcePath || location.pathname);
        }
        catch (error) {
            if (error.status === 404) {
                (_a = app.onPageNotFound) === null || _a === void 0 ? void 0 : _a.call(app, {
                    path: location.pathname
                });
            }
            else {
                throw new Error(error);
            }
        }
        if (!element)
            { return; }
        var pageConfig = config.routes.find(function (r) {
            var path = addLeadingSlash(r.path);
            return path === location.pathname || alias[path] === location.pathname;
        });
        var enablePullDownRefresh = false;
        runtime.eventCenter.trigger('__taroRouterChange', {
            toLocation: {
                path: location.pathname
            }
        });
        if (pageConfig) {
            document.title = (_b = pageConfig.navigationBarTitleText) !== null && _b !== void 0 ? _b : document.title;
            enablePullDownRefresh = pageConfig.enablePullDownRefresh;
        }
        var shouldLoad = false;
        if (action === 'POP') {
            unloadPage(runtime.Current.page);
            var delta = historyBackDelta;
            while (delta-- > 1) {
                unloadPage(stacks.slice(-1)[0]);
            }
            // 最终必须重置为 1
            setHistoryBackDelta(1);
            var prevIndex = stacks.reduceRight(function (p, s, i) {
                if (p !== 0)
                    { return p; }
                else if (s.path === location.pathname + runtime.stringify(qs(i)))
                    { return i; }
                else
                    { return 0; }
            }, 0);
            var prev = stacks[prevIndex];
            if (prev) {
                showPage(prev, pageConfig, prevIndex);
            }
            else {
                shouldLoad = true;
            }
        }
        else if (action === 'PUSH') {
            hidePage(runtime.Current.page);
            shouldLoad = true;
        }
        else if (action === 'REPLACE') {
            unloadPage(runtime.Current.page);
            shouldLoad = true;
        }
        if (shouldLoad) {
            var el = (_c = element.default) !== null && _c !== void 0 ? _c : element;
            var config$1 = Object.assign({}, pageConfig);
            delete config$1['path'];
            delete config$1['load'];
            var pathname = basename ? location.pathname.replace(basename, '') : location.pathname;
            var page = runtime.createPageConfig(enablePullDownRefresh ? (_d = runtimeHooks.createPullDownComponent) === null || _d === void 0 ? void 0 : _d.call(runtimeHooks, el, location.pathname, framework, routerConfig.PullDownRefresh) : el, pathname + runtime.stringify(qs(stacks.length)), {}, config$1);
            loadPage(page, pageConfig, stacks.length);
        }
    }, 500);
    if (exports.history.location.pathname === '/') {
        exports.history.replace(parsePath(routes[0].path + exports.history.location.search));
    }
    render({ location: exports.history.location, action: r.Push });
    app.onShow(qs(stacks.length));
    return exports.history.listen(render);
}

exports.createRouter = createRouter;
exports.getCurrentPages = getCurrentPages;
exports.navigateBack = navigateBack;
exports.navigateTo = navigateTo;
exports.reLaunch = reLaunch;
exports.redirectTo = redirectTo;
exports.switchTab = switchTab;
//# sourceMappingURL=index.js.map
