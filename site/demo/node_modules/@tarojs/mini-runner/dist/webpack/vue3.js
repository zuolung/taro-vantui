"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.customVue3Chain = void 0;
const helper_1 = require("@tarojs/helper");
const webpack = require("webpack");
const template_1 = require("@tarojs/shared/dist/template");
const component_1 = require("../template/component");
const CUSTOM_WRAPPER = 'custom-wrapper';
function customVue3Chain(chain) {
    let vueLoaderPath;
    try {
        vueLoaderPath = require.resolve('vue-loader', {
            paths: [process.cwd()]
        });
    }
    catch (error) {
        console.log(helper_1.chalk.yellow('找不到 vue-loader，请先安装。'));
        process.exit(1);
    }
    const { VueLoaderPlugin } = require(vueLoaderPath);
    chain.resolve.alias
        .set('vue', '@vue/runtime-dom');
    chain
        .plugin('vueLoaderPlugin')
        .use(VueLoaderPlugin);
    chain
        .plugin('defined')
        .use(webpack.DefinePlugin, [{
            __VUE_OPTIONS_API__: JSON.stringify(true),
            __VUE_PROD_DEVTOOLS__: JSON.stringify(false)
        }]);
    chain.module
        .rule('vue')
        .test(helper_1.REG_VUE)
        .use('vueLoader')
        .loader(vueLoaderPath)
        .options({
        optimizeSSR: false,
        transformAssetUrls: {
            video: ['src', 'poster'],
            'live-player': 'src',
            audio: 'src',
            source: 'src',
            image: 'src',
            'cover-image': 'src'
        },
        compilerOptions: {
            // https://github.com/vuejs/vue-next/blob/master/packages/compiler-core/src/options.ts
            nodeTransforms: [(node) => {
                    if (node.type === 1 /* ELEMENT */) {
                        node = node;
                        const nodeName = node.tag;
                        if (template_1.capitalize(template_1.toCamelCase(nodeName)) in template_1.internalComponents) {
                            // change only ElementTypes.COMPONENT to ElementTypes.ELEMENT
                            // and leave ElementTypes.SLOT untouched
                            if (node.tagType === 1 /* COMPONENT */) {
                                node.tagType = 0; /* ELEMENT */
                            }
                            component_1.componentConfig.includes.add(nodeName);
                        }
                        if (nodeName === CUSTOM_WRAPPER) {
                            node.tagType = 0; /* ELEMENT */
                            component_1.componentConfig.thirdPartyComponents.set(CUSTOM_WRAPPER, new Set());
                        }
                        const usingComponent = component_1.componentConfig.thirdPartyComponents.get(nodeName);
                        if (usingComponent != null) {
                            node.props.forEach(prop => {
                                var _a;
                                if (prop.type === 6 /* ATTRIBUTE */) {
                                    usingComponent.add(prop.name);
                                }
                                else if (prop.type === 7 /* DIRECTIVE */) {
                                    prop = prop;
                                    if (((_a = prop.arg) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SimpleExpression */) {
                                        let value = prop.arg.content;
                                        if (prop.name === 'on') {
                                            value = `on${value}`;
                                        }
                                        usingComponent.add(value);
                                    }
                                }
                            });
                        }
                    }
                }]
        }
    });
}
exports.customVue3Chain = customVue3Chain;
//# sourceMappingURL=vue3.js.map